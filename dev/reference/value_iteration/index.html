<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Value Iteration · IntervalMDP.jl</title><meta name="title" content="Value Iteration · IntervalMDP.jl"/><meta property="og:title" content="Value Iteration · IntervalMDP.jl"/><meta property="twitter:title" content="Value Iteration · IntervalMDP.jl"/><meta name="description" content="Documentation for IntervalMDP.jl."/><meta property="og:description" content="Documentation for IntervalMDP.jl."/><meta property="twitter:description" content="Documentation for IntervalMDP.jl."/><meta property="og:url" content="https://www.baymler.com/IntervalMDP.jl/reference/value_iteration/"/><meta property="twitter:url" content="https://www.baymler.com/IntervalMDP.jl/reference/value_iteration/"/><link rel="canonical" href="https://www.baymler.com/IntervalMDP.jl/reference/value_iteration/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="IntervalMDP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IntervalMDP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><a class="tocitem" href="../../data/">Data formats</a></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../algorithms/">Algorithms</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li class="is-active"><a class="tocitem" href>Value Iteration</a><ul class="internal"><li><a class="tocitem" href="#Bellman-update"><span>Bellman update</span></a></li></ul></li><li><a class="tocitem" href="../data/">Data Storage</a></li></ul></li><li><a class="tocitem" href="../../api/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Value Iteration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Value Iteration</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl/blob/main/docs/src/reference/value_iteration.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Value-iteration"><a class="docs-heading-anchor" href="#Value-iteration">Value iteration</a><a id="Value-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Value-iteration" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.value_iteration" href="#IntervalMDP.value_iteration"><code>IntervalMDP.value_iteration</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">value_iteration(problem::Problem; callback=nothing)</code></pre><p>Solve minimizes/mazimizes optimistic/pessimistic specification problems using value iteration for interval Markov processes. </p><p>It is possible to provide a callback function that will be called at each iteration with the current value function and iteration count. The callback function should have the signature <code>callback(V::AbstractArray, k::Int)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">prob1 = IntervalProbabilities(;
    lower = [
        0.0 0.5
        0.1 0.3
        0.2 0.1
    ],
    upper = [
        0.5 0.7
        0.6 0.5
        0.7 0.3
    ],
)

prob2 = IntervalProbabilities(;
    lower = [
        0.1 0.2
        0.2 0.3
        0.3 0.4
    ],
    upper = [
        0.6 0.6
        0.5 0.5
        0.4 0.4
    ],
)

prob3 = IntervalProbabilities(;
    lower = [0.0; 0.0; 1.0],
    upper = [0.0; 0.0; 1.0]
)

transition_probs = [prob1, prob2, prob3]
initial_state = 1
mdp = IntervalMarkovDecisionProcess(transition_probs, initial_state)

terminal_states = [3]
time_horizon = 10
prop = FiniteTimeReachability(terminal_states, time_horizon)
spec = Specification(prop, Pessimistic, Maximize)
problem = Problem(mdp, spec)
V, k, residual = value_iteration(problem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/value_iteration.jl#L21-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.control_synthesis" href="#IntervalMDP.control_synthesis"><code>IntervalMDP.control_synthesis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">control_synthesis(problem::Problem; callback=nothing)</code></pre><p>Compute the optimal control strategy for the given problem (system + specification). If the specification is finite time, then the strategy is time-varying, with the returned strategy being in step order (i.e., the first element of the returned vector is the strategy for the first time step). If the specification is infinite time, then the strategy is stationary and only a single vector of length <code>num_states(system)</code> is returned.</p><p>It is possible to provide a callback function that will be called at each iteration with the current value function and iteration count. The callback function should have the signature <code>callback(V::AbstractArray, k::Int)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/synthesis.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.StationaryStrategy" href="#IntervalMDP.StationaryStrategy"><code>IntervalMDP.StationaryStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StationaryStrategy</code></pre><p>A stationary strategy is a strategy that is the same for all time steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.TimeVaryingStrategy" href="#IntervalMDP.TimeVaryingStrategy"><code>IntervalMDP.TimeVaryingStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeVaryingStrategy</code></pre><p>A time-varying strategy is a strategy that <em>may</em> vary over time. Since we need to store the strategy for each time step,  the strategy is finite, and thus only applies to finite time specifications, of the same length as the strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L52-L57">source</a></section></article><h2 id="Bellman-update"><a class="docs-heading-anchor" href="#Bellman-update">Bellman update</a><a id="Bellman-update-1"></a><a class="docs-heading-anchor-permalink" href="#Bellman-update" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.bellman" href="#IntervalMDP.bellman"><code>IntervalMDP.bellman</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bellman(V, prob; upper_bound = false)</code></pre><p>Compute robust Bellman update with the value function <code>V</code> and the interval probabilities <code>prob</code>  that upper or lower bounds the expectation of the value function <code>V</code> via O-maximization [1]. Whether the expectation is maximized or minimized is determined by the <code>upper_bound</code> keyword argument. That is, if <code>upper_bound == true</code> then an upper bound is computed and if <code>upper_bound == false</code> then a lower bound is computed.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">prob = IntervalProbabilities(;
    lower = sparse_hcat(
        SparseVector(15, [4, 10], [0.1, 0.2]),
        SparseVector(15, [5, 6, 7], [0.5, 0.3, 0.1]),
    ),
    upper = sparse_hcat(
        SparseVector(15, [1, 4, 10], [0.5, 0.6, 0.7]),
        SparseVector(15, [5, 6, 7], [0.7, 0.5, 0.3]),
    ),
)

Vprev = collect(1:15)
Vcur = bellman(Vprev, prob; upper_bound = false)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function will construct a workspace object and an output vector. For a hot-loop, it is more efficient to use <code>bellman!</code> and pass in pre-allocated objects.</p></div></div><p>[1] M. Lahijanian, S. B. Andersson and C. Belta, &quot;Formal Verification and Synthesis for Discrete-Time Stochastic Systems,&quot; in IEEE Transactions on Automatic Control, vol. 60, no. 8, pp. 2031-2045, Aug. 2015, doi: 10.1109/TAC.2015.2398883.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/bellman.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.bellman!" href="#IntervalMDP.bellman!"><code>IntervalMDP.bellman!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bellman!(workspace, strategy_cache, Vres, V, prob, stateptr; upper_bound = false, maximize = true)</code></pre><p>Compute in-place robust Bellman update with the value function <code>V</code> and the interval probabilities <code>prob</code> that upper or lower bounds the expectation of the value function <code>V</code> via O-maximization [1]. Whether the expectation is maximized or minimized is determined by the <code>upper_bound</code> keyword argument. That is, if <code>upper_bound == true</code> then an upper bound is computed and if <code>upper_bound == false</code> then a lower bound is computed. </p><p>The output is constructed in the input <code>Vres</code> and returned. The workspace object is also modified, and depending on the type, the strategy cache may be modified as well. See <a href="#IntervalMDP.construct_workspace"><code>construct_workspace</code></a> and <a href="#IntervalMDP.construct_strategy_cache"><code>construct_strategy_cache</code></a> for more details on how to pre-allocate the workspace and strategy cache.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">prob = IntervalProbabilities(;
    lower = sparse_hcat(
        SparseVector(15, [4, 10], [0.1, 0.2]),
        SparseVector(15, [5, 6, 7], [0.5, 0.3, 0.1]),
    ),
    upper = sparse_hcat(
        SparseVector(15, [1, 4, 10], [0.5, 0.6, 0.7]),
        SparseVector(15, [5, 6, 7], [0.7, 0.5, 0.3]),
    ),
)

V = collect(1:15)
workspace = construct_workspace(prob)
strategy_cache = construct_strategy_cache(NoStrategyConfig())
Vres = similar(V)

Vres = bellman!(workspace, strategy_cache, Vres, V, prob; upper_bound = false, maximize = true)</code></pre><p>[1] M. Lahijanian, S. B. Andersson and C. Belta, &quot;Formal Verification and Synthesis for Discrete-Time Stochastic Systems,&quot; in IEEE Transactions on Automatic Control, vol. 60, no. 8, pp. 2031-2045, Aug. 2015, doi: 10.1109/TAC.2015.2398883.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/bellman.jl#L39-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.construct_workspace" href="#IntervalMDP.construct_workspace"><code>IntervalMDP.construct_workspace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_workspace(mp::IntervalMarkovProcess)</code></pre><p>Construct a workspace for computing the Bellman update, given a value function. If the Bellman update is used in a hot-loop, it is more efficient to use this function to preallocate the workspace and reuse across iterations.</p><p>The workspace type is determined by the type and size of the transition probability matrix, as well as the number of threads available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/workspace.jl#L4-L13">source</a></section><section><div><pre><code class="language-julia hljs">construct_workspace(prob::IntervalProbabilities)</code></pre><p>Construct a workspace for computing the Bellman update, given a value function. If the Bellman update is used in a hot-loop, it is more efficient to use this function to preallocate the workspace and reuse across iterations.</p><p>The workspace type is determined by the type and size of the transition probability matrix, as well as the number of threads available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/workspace.jl#L57-L66">source</a></section><section><div><pre><code class="language-julia hljs">construct_workspace(prob::OrthogonalIntervalProbabilities)</code></pre><p>Construct a workspace for computing the Bellman update, given a value function. If the Bellman update is used in a hot-loop, it is more efficient to use this function to preallocate the workspace and reuse across iterations.</p><p>The workspace type is determined by the type and size of the transition probability matrix, as well as the number of threads available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/workspace.jl#L191-L200">source</a></section><section><div><pre><code class="language-julia hljs">construct_workspace(prob::OrthogonalIntervalProbabilities)</code></pre><p>Construct a workspace for computing the Bellman update, given a value function. If the Bellman update is used in a hot-loop, it is more efficient to use this function to preallocate the workspace and reuse across iterations.</p><p>The workspace type is determined by the type and size of the transition probability matrix, as well as the number of threads available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/workspace.jl#L251-L260">source</a></section><section><div><pre><code class="language-julia hljs">construct_workspace(prob::MixtureIntervalProbabilities)</code></pre><p>Construct a workspace for computing the Bellman update, given a value function. If the Bellman update is used in a hot-loop, it is more efficient to use this function to preallocate the workspace and reuse across iterations.</p><p>The workspace type is determined by the type and size of the transition probability matrix, as well as the number of threads available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/workspace.jl#L420-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.construct_strategy_cache" href="#IntervalMDP.construct_strategy_cache"><code>IntervalMDP.construct_strategy_cache</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_strategy_cache(mp::Union{IntervalProbabilities, IntervalMarkovProcess}, config::AbstractStrategyConfig)</code></pre><p>Construct a strategy cache from a configuration for a given interval Markov process. The resuling cache type depends on the configuration and the device to store the strategy depends on the device of the Markov process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.GivenStrategyConfig" href="#IntervalMDP.GivenStrategyConfig"><code>IntervalMDP.GivenStrategyConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GivenStrategyConfig</code></pre><p>A configuration for a strategy cache where a given strategy is applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.NoStrategyConfig" href="#IntervalMDP.NoStrategyConfig"><code>IntervalMDP.NoStrategyConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoStrategyConfig</code></pre><p>A configuration for a strategy cache that does not store policies. See <a href="#IntervalMDP.construct_strategy_cache"><code>construct_strategy_cache</code></a> for more details on how to construct the cache from the configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.StationaryStrategyConfig" href="#IntervalMDP.StationaryStrategyConfig"><code>IntervalMDP.StationaryStrategyConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StationaryStrategyConfig</code></pre><p>A configuration for a strategy cache that stores stationary policies. Note that the strategy is updated at each iteration of the value iteration algorithm, if a new choice is strictly better than the previous one. See [1, Section 4.3] for more details why this is necessary. See <a href="#IntervalMDP.construct_strategy_cache"><code>construct_strategy_cache</code></a> for more details on how to construct the cache from the configuration.</p><p>[1] Forejt, Vojtěch, et al. &quot;Automated verification techniques for probabilistic systems.&quot; Formal Methods for Eternal Networked Software Systems: 11th International School on Formal Methods for the Design of Computer, Communication and Software Systems, SFM 2011, Bertinoro, Italy, June 13-18, 2011. Advanced Lectures 11 (2011): 53-113.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.TimeVaryingStrategyConfig" href="#IntervalMDP.TimeVaryingStrategyConfig"><code>IntervalMDP.TimeVaryingStrategyConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeVaryingStrategyConfig</code></pre><p>A configuration for a strategy cache that stores time-varying policies. See <a href="#IntervalMDP.construct_strategy_cache"><code>construct_strategy_cache</code></a> for more details on how to construct the cache from the configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/ef2167a1351d3b5da1256d9851020a47df65af21/src/strategy.jl#L102-L107">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../specifications/">« Specifications</a><a class="docs-footer-nextpage" href="../data/">Data Storage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 28 April 2025 15:33">Monday 28 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
