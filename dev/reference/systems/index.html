<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Systems · IntervalMDP.jl</title><meta name="title" content="Systems · IntervalMDP.jl"/><meta property="og:title" content="Systems · IntervalMDP.jl"/><meta property="twitter:title" content="Systems · IntervalMDP.jl"/><meta name="description" content="Documentation for IntervalMDP.jl."/><meta property="og:description" content="Documentation for IntervalMDP.jl."/><meta property="twitter:description" content="Documentation for IntervalMDP.jl."/><meta property="og:url" content="https://www.baymler.com/IntervalMDP.jl/reference/systems/"/><meta property="twitter:url" content="https://www.baymler.com/IntervalMDP.jl/reference/systems/"/><link rel="canonical" href="https://www.baymler.com/IntervalMDP.jl/reference/systems/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="IntervalMDP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IntervalMDP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><a class="tocitem" href="../../models/">Models</a></li><li><a class="tocitem" href="../../specifications/">Specifications</a></li><li><a class="tocitem" href="../../algorithms/">Algorithms</a></li><li><span class="tocitem">API reference</span><ul><li class="is-active"><a class="tocitem" href>Systems</a><ul class="internal"><li><a class="tocitem" href="#api-frmdp"><span>Factored RMDPs</span></a></li><li><a class="tocitem" href="#Probability-representation"><span>Probability representation</span></a></li><li><a class="tocitem" href="#Deterministic-Finite-Automaton-(DFA)"><span>Deterministic Finite Automaton (DFA)</span></a></li></ul></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li><a class="tocitem" href="../solve/">Solve Interface</a></li><li><a class="tocitem" href="../data/">Data Storage</a></li><li><a class="tocitem" href="../../api/">Index</a></li></ul></li><li><a class="tocitem" href="../../data/">Data formats</a></li><li><a class="tocitem" href="../../developer/">Developer docs</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API reference</a></li><li class="is-active"><a href>Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl/blob/main/docs/src/reference/systems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="System-representation"><a class="docs-heading-anchor" href="#System-representation">System representation</a><a id="System-representation-1"></a><a class="docs-heading-anchor-permalink" href="#System-representation" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="IntervalMDP.num_states"><a class="docstring-binding" href="#IntervalMDP.num_states"><code>IntervalMDP.num_states</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_states(mp::IntervalMarkovProcess)</code></pre><p>Return the number of states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovProcess.jl#L23-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_actions"><a class="docstring-binding" href="#IntervalMDP.num_actions"><code>IntervalMDP.num_actions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_actions(mp::IntervalMarkovProcess)</code></pre><p>Return the number of actions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovProcess.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.initial_states"><a class="docstring-binding" href="#IntervalMDP.initial_states"><code>IntervalMDP.initial_states</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initial_states(mp::IntervalMarkovProcess)</code></pre><p>Return the initial states. If the initial states are not specified, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovProcess.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.AllStates"><a class="docstring-binding" href="#IntervalMDP.AllStates"><code>IntervalMDP.AllStates</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AllStates</code></pre><p>A type to represent all states in a Markov process. This type is used to specify all states as the initial states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovProcess.jl#L15-L19">source</a></section></details></article><h2 id="api-frmdp"><a class="docs-heading-anchor" href="#api-frmdp">Factored RMDPs</a><a id="api-frmdp-1"></a><a class="docs-heading-anchor-permalink" href="#api-frmdp" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="IntervalMDP.FactoredRobustMarkovDecisionProcess"><a class="docstring-binding" href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>IntervalMDP.FactoredRobustMarkovDecisionProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FactoredRobustMarkovDecisionProcess{N, M, P &lt;: NTuple{N, Marginal}, VI &lt;: InitialStates} &lt;: IntervalMarkovProcess</code></pre><p>Factored Robust Markov Decision Processes (fRMDPs) [<a href="../../references/#schnitzer2025efficient">1</a>, <a href="../../references/#delgado2011efficient">2</a>] are an extension of Robust Markov Decision Processes (RMDPs) [<a href="../../references/#nilim2005robust">3</a>–<a href="../../references/#suilen2024robust">5</a>] that incorporate a factored representation of the state and action spaces, i.e. with state and action variables.</p><p>Formally, a fRMDP <span>$M$</span> is a tuple <span>$M = (S, S_0, A, \mathcal{G}, \Gamma)$</span>, where</p><ul><li><span>$S = S_1 \times \cdots \times S_n$</span> is a finite set of joint states with <span>$S_i$</span>    being a finite set of states for the <span>$i$</span>-th state variable,</li><li><span>$S_0 \subseteq S$</span> is a set of initial states,</li><li><span>$A = A_1 \times \cdots \times A_m$</span> is a finite set of joint actions with <span>$A_j$</span>    being a finite set of actions for the <span>$j$</span>-th action variable,</li><li><span>$\mathcal{G} = (\mathcal{V}, \mathcal{E})$</span> is a directed bipartite graph with nodes    <span>$\mathcal{V} = \mathcal{V}_{ind} \cup \mathcal{V}_{cond} = \{S_1, \ldots, S_n, A_1, \ldots, A_m\} \cup \{S&#39;_1, \ldots, S&#39;_n\}$</span>   representing the state and action variables and their next-state counterparts, and edges    <span>$\mathcal{E} \subseteq \mathcal{V}_{ind} \times \mathcal{V}_{cond}$</span>   representing dependencies of <span>$S&#39;_i$</span> on <span>$S_j$</span> and <span>$A_k$</span>,</li><li><span>$\Gamma = \{\Gamma_{s, a}\}_{s \in S, a \in A}$</span> is a set of ambiguity sets for source-action pair <span>$(s, a)$</span>,    where each <span>$\Gamma_{s, a} = \bigotimes_{i=1}^n \Gamma^i_{\text{Pa}_\mathcal{G}(S&#39;_i) \cap (s, a)}$</span> is   a product of ambiguity sets <span>$\Gamma^i_{\text{Pa}_\mathcal{G}(S&#39;_i) \cap (s, a)}$</span> along each marginal <span>$i$</span> conditional   on the values in <span>$(s, a)$</span> of the parent variables <span>$\text{Pa}_\mathcal{G}(S&#39;_i)$</span> of <span>$S&#39;_i$</span> in <span>$\mathcal{G}$</span>, i.e.</li></ul><p class="math-container">\[    \Gamma_{s, a} = \left\{ \gamma \in \mathcal{D}(S) \,:\, \gamma(t) = \prod_{i=1}^n \gamma^i(t_i | s_{\text{Pa}_{\mathcal{G}_S}(S&#39;_i)}, a_{\text{Pa}_{\mathcal{G}_A}(S&#39;_i)}), \, \gamma^i(\cdot | s_{\text{Pa}_{\mathcal{G}_S}(S&#39;_i)}, a_{\text{Pa}_{\mathcal{G}_A}(S&#39;_i)}) \in \Gamma^i_{\text{Pa}_\mathcal{G}(S&#39;_i)} \right\}.\]</p><p>For a given source-action pair <span>$(s, a) \in S \times A$</span>, any distribution <span>$\gamma_{s, a} \in \Gamma_{s, a}$</span> is called a feasible distribution, and feasible transitions are triplets <span>$(s, a, t) \in S \times A \times S$</span> where <span>$t \in \mathop{supp}(\gamma_{s, a})$</span> for any feasible distribution <span>$\gamma_{s, a} \in \Gamma_{s, a}$</span>.</p><p><strong>Type parameters</strong></p><ul><li><code>N</code> is the number of state variables.</li><li><code>M</code> is the number of action variables.</li><li><code>P &lt;: NTuple{N, Marginal}</code> is a tuple type with a (potentially different) type for each marginal.</li><li><code>VI &lt;: InitialStates</code> is the type of initial states.</li></ul><p><strong>Fields</strong></p><ul><li><code>state_vars::NTuple{N, Int32}</code>: the number of values <span>$|S_i|$</span> for each state variable <span>$S_i$</span> as a tuple.</li><li><code>action_vars::NTuple{M, Int32}</code>: the number of values <span>$|A_k|$</span> for each action variable <span>$A_k$</span> as a tuple.</li><li><code>source_dims::NTuple{N, Int32}</code>: for systems with terminal states along certain slices, it is possible to avoid   specifying them by using <code>source_dims</code> less than <code>state_vars</code>; this is useful e.g. in building abstractions.   The terminal states must be the last value for the slice dimension. If not supplied, it is assumed <code>source_dims == state_vars</code>.</li><li><code>transition::P</code> is the marginal ambiguity sets. For a given source-action pair <span>$(s, a) \in S \times A$</span>,   any <a href="#IntervalMDP.Marginal"><code>Marginal</code></a> element of <code>transition</code> subselects <code>s</code> and <code>a</code> corresponding to its <a href="#IntervalMDP.state_variables-Tuple{Marginal}"><code>state_variables</code></a>   and <a href="#IntervalMDP.action_variables-Tuple{Marginal}"><code>action_variables</code></a>, i.e. it encodes the operation <code>\text{Pa}_\mathcal{G}(S&#39;_i) \cap (s, a)</code>.   The underlying <code>ambiguity_sets</code> object on <code>Marginal</code> encodes <span>$\Gamma^i_{\text{Pa}_\mathcal{G}(S&#39;_i) \cap (s, a)}$</span>   for all values of <span>$\text{Pa}_\mathcal{G}(S&#39;_i)$</span>. See <a href="#IntervalMDP.Marginal"><code>Marginal</code></a> for details about the layout of the underlying   <code>AbstractAmbiguitySets</code> object.</li><li><code>initial_states::VI</code>: stores a representation of <code>S_0</code>. If no set of initial_states are given, then it is simply assigned   the zero-byte object <code>AllStates()</code>, which represents that all states are potential initial states. It is not used within   the value iteration.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using IntervalMDP

state_vars = (2, 3)
action_vars = (1, 2)

state_indices = (1, 2)
action_indices = (1,)
state_dims = (2, 3)
action_dims = (1,)
marginal1 = Marginal(IntervalAmbiguitySets(;
    # 6 ambiguity sets = 2 * 3 source states, 1 action
    # Column layout: (a¹₁, s¹₁, s²₁), (a¹₁, s¹₂, s²₁), (a¹₁, s¹₁, s²₂), (a¹₁, s¹₂, s²₂), (a¹₁, s¹₁, s²₃), (a¹₁, s¹₂, s²₃)
    # Equivalent to CartesianIndices(actions_dims..., state_dims...), i.e. actions first, then states in lexicographic order
    lower = [
        1/15  7/30  1/15  13/30  4/15  1/6
        2/5   7/30  1/30  11/30  2/15  1/10
    ],
    upper = [
        17/30  7/10   2/3   4/5  7/10  2/3
        9/10   13/15  9/10  5/6  4/5   14/15
    ]
), state_indices, action_indices, state_dims, action_dims)

state_indices = (2,)
action_indices = (2,)
state_dims = (3,)
action_dims = (2,)
marginal2 = Marginal(IntervalAmbiguitySets(;
    # 6 ambiguity sets = 3 source states, 2 actions
    # Column layout: (a²₁, s²₁), (a²₂, s²₁), (a²₁, s²₂), (a²₂, s²₂), (a²₁, s²₃), (a²₂, s²₃)
    # Equivalent to CartesianIndices(actions_dims..., state_dims...), i.e. actions first, then states in lexicographic order
    lower = [
        1/30  1/3   1/6   1/15  2/5   2/15
        4/15  1/4   1/6   1/30  2/15  1/30
        2/15  7/30  1/10  7/30  7/15  1/5
    ],
    upper = [
        2/3    7/15  4/5    11/30  19/30  1/2
        23/30  4/5   23/30  3/5    7/10   8/15
        7/15   4/5   23/30  7/10   7/15   23/30
    ]
), state_indices, action_indices, state_dims, action_dims)

initial_states = [(1, 1)]  # Initial states are optional
mdp = FactoredRobustMarkovDecisionProcess(state_vars, action_vars, (marginal1, marginal2), initial_states)

# output

FactoredRobustMarkovDecisionProcess
├─ 2 state variables with cardinality: (2, 3)
├─ 2 action variables with cardinality: (1, 2)
├─ Initial states: [(1, 1)]
├─ Transition marginals:
│  ├─ Marginal 1:
│  │  ├─ Conditional variables: states = (1, 2), actions = (1,)
│  │  └─ Ambiguity set type: Interval (dense, Matrix{Float64})
│  └─ Marginal 2:
│     ├─ Conditional variables: states = (2,), actions = (2,)
│     └─ Ambiguity set type: Interval (dense, Matrix{Float64})
└─Inferred properties
   ├─Model type: Factored Interval MDP
   ├─Number of states: 6
   ├─Number of actions: 2
   ├─Default model checking algorithm: Robust Value Iteration
   └─Default Bellman operator algorithm: Recursive O-Maximization</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/FactoredRobustMarkovDecisionProcess.jl#L1-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.state_values-Tuple{FactoredRobustMarkovDecisionProcess}"><a class="docstring-binding" href="#IntervalMDP.state_values-Tuple{FactoredRobustMarkovDecisionProcess}"><code>IntervalMDP.state_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_values(mdp::FactoredRMDP)</code></pre><p>Return a tuple with the number of states for each state variable in the fRMDP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/FactoredRobustMarkovDecisionProcess.jl#L384-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.action_values-Tuple{FactoredRobustMarkovDecisionProcess}"><a class="docstring-binding" href="#IntervalMDP.action_values-Tuple{FactoredRobustMarkovDecisionProcess}"><code>IntervalMDP.action_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">action_values(mdp::FactoredRMDP)</code></pre><p>Return a tuple with the number of actions for each action variable in the fRMDP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/FactoredRobustMarkovDecisionProcess.jl#L392-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.marginals-Tuple{FactoredRobustMarkovDecisionProcess}"><a class="docstring-binding" href="#IntervalMDP.marginals-Tuple{FactoredRobustMarkovDecisionProcess}"><code>IntervalMDP.marginals</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">marginals(mdp::FactoredRMDP)</code></pre><p>Return the marginals of the fRMDP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/FactoredRobustMarkovDecisionProcess.jl#L399-L403">source</a></section></details></article><h3 id="Convenience-constructors-for-subclasses-of-fRMDPs"><a class="docs-heading-anchor" href="#Convenience-constructors-for-subclasses-of-fRMDPs">Convenience constructors for subclasses of fRMDPs</a><a id="Convenience-constructors-for-subclasses-of-fRMDPs-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-constructors-for-subclasses-of-fRMDPs" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="IntervalMDP.IntervalMarkovChain"><a class="docstring-binding" href="#IntervalMDP.IntervalMarkovChain"><code>IntervalMDP.IntervalMarkovChain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">IntervalMarkovChain(ambiguity_set::IntervalAmbiguitySets, initial_states=AllStates())</code></pre><p>A convenience constructor for a <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a> representing an interval Markov chain, as IMCs are a subclass of fRMDPs, from a single <a href="#IntervalMDP.IntervalAmbiguitySets"><code>IntervalAmbiguitySets</code></a> object.</p><p>Formally, an IMC <span>$M$</span> is a tuple <span>$M = (S, S_0, \Gamma)$</span>, where</p><ul><li><span>$S$</span> is a finite set of states,</li><li><span>$S_0 \subseteq S$</span> is a set of initial states,</li><li><span>$\Gamma = \{\Gamma_{s}\}_{s \in S}$</span> is a set of ambiguity sets for source state <span>$s$</span>,   where each <span>$\Gamma_{s}$</span> is an <em>interval</em> ambiguity set over <span>$S$</span>.</li></ul><p>Notice also that an IMC is an <a href="#IntervalMDP.IntervalMarkovDecisionProcess"><code>IntervalMarkovDecisionProcess</code></a> with a single action.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using IntervalMDP

prob = IntervalAmbiguitySets(;
    lower = [
        0     1/2   0
        1/10  3/10  0
        1/5   1/10  1
    ],
    upper = [
        1/2   7/10  0
        3/5   1/2   0
        7/10  3/10  1
    ],
)

initial_states = [1]
mc = IntervalMarkovChain(prob, initial_states)

# output

FactoredRobustMarkovDecisionProcess
├─ 1 state variables with cardinality: (3,)
├─ 1 action variables with cardinality: (1,)
├─ Initial states: [1]
├─ Transition marginals:
│  └─ Marginal 1:
│     ├─ Conditional variables: states = (1,), actions = (1,)
│     └─ Ambiguity set type: Interval (dense, Matrix{Float64})
└─Inferred properties
   ├─Model type: Interval MDP
   ├─Number of states: 3
   ├─Number of actions: 1
   ├─Default model checking algorithm: Robust Value Iteration
   └─Default Bellman operator algorithm: O-Maximization</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovChain.jl#L27-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.IntervalMarkovDecisionProcess"><a class="docstring-binding" href="#IntervalMDP.IntervalMarkovDecisionProcess"><code>IntervalMDP.IntervalMarkovDecisionProcess</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">IntervalMarkovDecisionProcess(ambiguity_set::IntervalAmbiguitySets, num_actions::Integer, initial_states::InitialStates = AllStates())</code></pre><p>A convenience constructor for a <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a> representing an interval Markov decision process, as IMDPs are a subclass of fRMDPs, from a single <a href="#IntervalMDP.IntervalAmbiguitySets"><code>IntervalAmbiguitySets</code></a> object and a specified number of actions.</p><p>Formally, an IMDP <span>$M$</span> is a tuple <span>$M = (S, S_0, A, \Gamma)$</span>, where</p><ul><li><span>$S$</span> is a finite set of states,</li><li><span>$S_0 \subseteq S$</span> is a set of initial states,</li><li><span>$A$</span> is a finite set of actions,</li><li>`<span>$\Gamma = \{\Gamma_{s,a}\}_{s \in S,a \in A}$</span> is a set of ambiguity sets for source-action pair <span>$(s, a)$</span>, where each <span>$\Gamma_{s,a}$</span> is an <em>interval</em> ambiguity set over <span>$S$</span>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using IntervalMDP

prob1 = IntervalAmbiguitySets(;
    lower = [
        0    1/2
        1/10 3/10
        1/5  1/10
    ],
    upper = [
        1/2  7/10
        3/5  1/2
        7/10 3/10
    ],
)

prob2 = IntervalAmbiguitySets(;
    lower = [
        1/10 1/5
        1/5  3/10
        3/10 2/5
    ],
    upper = [
        3/5 3/5
        1/2 1/2
        2/5 2/5
    ],
)

prob3 = IntervalAmbiguitySets(;
    lower = Float64[
        0 0
        0 0
        1 1
    ],
    upper = Float64[
        0 0
        0 0
        1 1
    ]
)

initial_states = [1]
mdp = IntervalMarkovDecisionProcess([prob1, prob2, prob3], initial_states)

# output

FactoredRobustMarkovDecisionProcess
├─ 1 state variables with cardinality: (3,)
├─ 1 action variables with cardinality: (2,)
├─ Initial states: [1]
├─ Transition marginals:
│  └─ Marginal 1:
│     ├─ Conditional variables: states = (1,), actions = (1,)
│     └─ Ambiguity set type: Interval (dense, Matrix{Float64})
└─Inferred properties
   ├─Model type: Interval MDP
   ├─Number of states: 3
   ├─Number of actions: 2
   ├─Default model checking algorithm: Robust Value Iteration
   └─Default Bellman operator algorithm: O-Maximization</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovDecisionProcess.jl#L13-L90">source</a></section><section><div><pre><code class="language-julia hljs">IntervalMarkovDecisionProcess(ps::Vector{&lt;:IntervalAmbiguitySets}, initial_states::InitialStates = AllStates())</code></pre><p>A convenience constructor for a <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a> representing an interval Markov decision process from a vector of <a href="#IntervalMDP.IntervalAmbiguitySets"><code>IntervalAmbiguitySets</code></a> objects, one for each state and with the same number of actions in each. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using IntervalMDP

prob = IntervalAmbiguitySets(;
    lower = [
        0    1/2  1/10 1/5  0 0
        1/10 3/10 1/5  3/10 0 0
        1/5  1/10 3/10 2/5  1 1
    ],
    upper = [
        1/2  7/10 3/5 2/5 0 0
        3/5  1/2  1/2 2/5 0 0
        7/10 3/10 2/5 2/5 1 1
    ],
)

num_actions = 2
initial_states = [1]
mdp = IntervalMarkovDecisionProcess(prob, num_actions, initial_states)

# output

FactoredRobustMarkovDecisionProcess
├─ 1 state variables with cardinality: (3,)
├─ 1 action variables with cardinality: (2,)
├─ Initial states: [1]
├─ Transition marginals:
│  └─ Marginal 1:
│     ├─ Conditional variables: states = (1,), actions = (1,)
│     └─ Ambiguity set type: Interval (dense, Matrix{Float64})
└─Inferred properties
   ├─Model type: Interval MDP
   ├─Number of states: 3
   ├─Number of actions: 2
   ├─Default model checking algorithm: Robust Value Iteration
   └─Default Bellman operator algorithm: O-Maximization</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/IntervalMarkovDecisionProcess.jl#L111-L156">source</a></section></details></article><h2 id="Probability-representation"><a class="docs-heading-anchor" href="#Probability-representation">Probability representation</a><a id="Probability-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Probability-representation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="IntervalMDP.Marginal"><a class="docstring-binding" href="#IntervalMDP.Marginal"><code>IntervalMDP.Marginal</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Marginal{A &lt;: AbstractAmbiguitySets, N, M, I &lt;: LinearIndices}</code></pre><p>A struct to represent the dependency graph of an fRMDP, namely by subselecting (in <code>getindex</code>) the (decomposed) state and action. Furthermore, the struct is responsible for converting the Cartesian index to a linear index for the underlying ambiguity sets.</p><div class="admonition is-todo" id="Todo-2d37f089d17846e9"><header class="admonition-header">Todo<a class="admonition-anchor" href="#Todo-2d37f089d17846e9" title="Permalink"></a></header><div class="admonition-body"><p>Describe source_dims</p></div></div><div class="admonition is-todo" id="Todo-3a3c2d65ad063b2f"><header class="admonition-header">Todo<a class="admonition-anchor" href="#Todo-3a3c2d65ad063b2f" title="Permalink"></a></header><div class="admonition-body"><p>Add example</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.ambiguity_sets-Tuple{Marginal}"><a class="docstring-binding" href="#IntervalMDP.ambiguity_sets-Tuple{Marginal}"><code>IntervalMDP.ambiguity_sets</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ambiguity_sets(p::Marginal)</code></pre><p>Return the underlying ambiguity sets of the marginal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.state_variables-Tuple{Marginal}"><a class="docstring-binding" href="#IntervalMDP.state_variables-Tuple{Marginal}"><code>IntervalMDP.state_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_variables(p::Marginal)</code></pre><p>Return the state variable indices of the marginal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.action_variables-Tuple{Marginal}"><a class="docstring-binding" href="#IntervalMDP.action_variables-Tuple{Marginal}"><code>IntervalMDP.action_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">action_variables(p::Marginal)</code></pre><p>Return the action variable indices of the marginal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.source_shape-Tuple{Marginal}"><a class="docstring-binding" href="#IntervalMDP.source_shape-Tuple{Marginal}"><code>IntervalMDP.source_shape</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">source_shape(p::Marginal)</code></pre><p>Return the shape of the source (state) variables of the marginal. The <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a>  checks if this is less than or equal to the corresponding state values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L167-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.action_shape-Tuple{Marginal}"><a class="docstring-binding" href="#IntervalMDP.action_shape-Tuple{Marginal}"><code>IntervalMDP.action_shape</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">action_shape(p::Marginal)</code></pre><p>Return the shape of the action variables of the marginal. The <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a> checks if this is equal to the corresponding action values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L175-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{Marginal, Any, Any}"><a class="docstring-binding" href="#Base.getindex-Tuple{Marginal, Any, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(p::Marginal, action, source)</code></pre><p>Get the ambiguity set corresponding to the given <code>source</code> (state) and <code>action</code>, where  the relevant indices of <code>source</code> and <code>action</code> are selected by <code>p.action_indices</code> and <code>p.state_indices</code> respectively. The selected index is then converted to a linear index for the underlying ambiguity sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L190-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_sets"><a class="docstring-binding" href="#IntervalMDP.num_sets"><code>IntervalMDP.num_sets</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_sets(ambiguity_sets::AbstractAmbiguitySets)</code></pre><p>Return the number of ambiguity sets in the AbstractAmbiguitySets object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/probabilities.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_target"><a class="docstring-binding" href="#IntervalMDP.num_target"><code>IntervalMDP.num_target</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_target(p::Marginal)</code></pre><p>Return the number of target states of the marginal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/Marginal.jl#L183-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.support"><a class="docstring-binding" href="#IntervalMDP.support"><code>IntervalMDP.support</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">support(ambiguity_set::AbstractAmbiguitySet)</code></pre><p>Return the support (set of indices with non-zero probability) of the ambiguity set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/probabilities.jl#L18-L22">source</a></section></details></article><h3 id="Interval-ambiguity-sets"><a class="docs-heading-anchor" href="#Interval-ambiguity-sets">Interval ambiguity sets</a><a id="Interval-ambiguity-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-ambiguity-sets" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="IntervalMDP.IntervalAmbiguitySets"><a class="docstring-binding" href="#IntervalMDP.IntervalAmbiguitySets"><code>IntervalMDP.IntervalAmbiguitySets</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntervalAmbiguitySets{R, MR &lt;: AbstractMatrix{R}}</code></pre><p>A matrix pair to represent the lower and upper bound of <code>num_sets(ambiguity_sets)</code> interval ambiguity sets (on the columns) to <code>num_target(ambiguity_sets)</code> destinations (on the rows). <a href="#IntervalMDP.Marginal">Marginal</a> adds interpretation to the column indices. The matrices can be <code>Matrix{R}</code> or <code>SparseMatrixCSC{R}</code>, or their CUDA equivalents.  Due to the space complexity, if modelling <a href="#IntervalMDP.IntervalMarkovChain">IntervalMarkovChains</a> or <a href="#IntervalMDP.IntervalMarkovDecisionProcess">IntervalMarkovDecisionProcesses</a>, it is recommended to use sparse matrices.</p><p>The columns represent the different ambiguity sets and the rows represent the targets. Due to the column-major format of Julia,  this is a more efficient representation in terms of cache locality.</p><p>The lower bound is explicitly stored, while the upper bound is computed from the lower bound and the gap. This choice is  because it simplifies repeated probability assignment using O-maximization [<a href="../../references/#givan2000bounded">7</a>, <a href="../../references/#lahijanian2015formal">8</a>].</p><p><strong>Fields</strong></p><ul><li><code>lower::MR</code>: The lower bound probabilities for <code>num_sets(ambiguity_sets)</code> ambiguity sets to <code>num_target(ambiguity_sets)</code> target states.</li><li><code>gap::MR</code>: The gap between upper and lower bound transition probabilities for <code>num_sets(ambiguity_sets)</code> ambiguity sets to <code>num_target(ambiguity_sets)</code> target states.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using IntervalMDP

dense_prob = IntervalAmbiguitySets(;
    lower = [0.0 0.5; 0.1 0.3; 0.2 0.1],
    upper = [0.5 0.7; 0.6 0.5; 0.7 0.3],
)

# output

IntervalAmbiguitySets
├─ Storage type: Matrix{Float64}
├─ Number of target states: 3
└─ Number of ambiguity sets: 2</code></pre><pre><code class="language-julia hljs">using IntervalMDP, SparseArrays
sparse_prob = IntervalAmbiguitySets(;
    lower = sparse_hcat(
        SparseVector(15, [4, 10], [0.1, 0.2]),
        SparseVector(15, [5, 6, 7], [0.5, 0.3, 0.1]),
    ),
    upper = sparse_hcat(
        SparseVector(15, [1, 4, 10], [0.5, 0.6, 0.7]),
        SparseVector(15, [5, 6, 7], [0.7, 0.5, 0.3]),
    ),
)

# output

IntervalAmbiguitySets
├─ Storage type: SparseArrays.FixedSparseCSC{Float64, Int64}
├─ Number of target states: 15
├─ Number of ambiguity sets: 2
├─ Maximum support size: 3
└─ Number of non-zeros: 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/IntervalAmbiguitySets.jl#L1-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.lower"><a class="docstring-binding" href="#IntervalMDP.lower"><code>IntervalMDP.lower</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lower(p::IntervalAmbiguitySet)</code></pre><p>Return the lower bound transition probabilities of the ambiguity set to all target states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/IntervalAmbiguitySets.jl#L361-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.upper"><a class="docstring-binding" href="#IntervalMDP.upper"><code>IntervalMDP.upper</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">upper(p::IntervalAmbiguitySet)</code></pre><p>Return the upper bound transition probabilities of the ambiguity set to all target states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/IntervalAmbiguitySets.jl#L369-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.gap"><a class="docstring-binding" href="#IntervalMDP.gap"><code>IntervalMDP.gap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gap(p::IntervalAmbiguitySet)</code></pre><p>Return the gap between upper and lower bound transition probabilities of the ambiguity set to all target states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/IntervalAmbiguitySets.jl#L378-L382">source</a></section></details></article><h2 id="Deterministic-Finite-Automaton-(DFA)"><a class="docs-heading-anchor" href="#Deterministic-Finite-Automaton-(DFA)">Deterministic Finite Automaton (DFA)</a><a id="Deterministic-Finite-Automaton-(DFA)-1"></a><a class="docs-heading-anchor-permalink" href="#Deterministic-Finite-Automaton-(DFA)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="IntervalMDP.DFA"><a class="docstring-binding" href="#IntervalMDP.DFA"><code>IntervalMDP.DFA</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DFA{
    T &lt;: TransitionFunction,  
    VT &lt;: AbstractVector{Int32},
    DA &lt;: AbstractDict{String, Int32}
}</code></pre><p>A type representing Deterministic Finite Automaton (DFA) which are finite automata with deterministic transitions.</p><p>Formally, let <span>$(Q, 2^{AP}, \delta, q_0, Q_{ac})$</span> be an DFA, where </p><ul><li><span>$Q$</span> is the set of states,</li><li><span>$Q_{ac} \subseteq Q$</span> is the set of accepting states,</li><li><span>$Q_0$</span> is the initial state,</li><li><span>$2^{AP}$</span> is the power set of automic propositions, and</li><li><span>$\delta : |Q| \times |2^{AP}| =&gt; |Q|$</span> is the deterministic transition function, for each state-input pair.</li></ul><p>Then the <code>DFA</code> type is defined as follows: indices <code>1:num_states</code> are the states in <span>$Q$</span>,  <code>transition</code> represents <span>$\delta$</span>, the set <span>$2^{AP}$</span> is , and <code>initial_state</code> is the initial state <span>$q_0$</span>.  See <a href="#IntervalMDP.TransitionFunction"><code>TransitionFunction</code></a> for more information on the structure of the transition function.</p><p><strong>Fields</strong></p><ul><li><code>transition::T</code>: transition function.</li><li><code>initial_state::Int32</code>: initial states.</li><li><code>accepting_states::VT</code>: vector of accepting states</li><li><code>labelmap::DA</code>: mapping from label to index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/DFA.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_states-Tuple{DFA}"><a class="docstring-binding" href="#IntervalMDP.num_states-Tuple{DFA}"><code>IntervalMDP.num_states</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_states(dfa::DFA)</code></pre><p>Return the number of states <span>$|Q|$</span> of the Deterministic Finite Automaton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/DFA.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_labels-Tuple{DFA}"><a class="docstring-binding" href="#IntervalMDP.num_labels-Tuple{DFA}"><code>IntervalMDP.num_labels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_labels(dfa::DFA)</code></pre><p>Return the number of labels (DFA inputs) in the Deterministic Finite Automaton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/DFA.jl#L125-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.transition-Tuple{DFA}"><a class="docstring-binding" href="#IntervalMDP.transition-Tuple{DFA}"><code>IntervalMDP.transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transition(dfa::DFA)</code></pre><p>Return the transition object of the Deterministic Finite Automaton. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/DFA.jl#L111-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.labelmap-Tuple{DFA}"><a class="docstring-binding" href="#IntervalMDP.labelmap-Tuple{DFA}"><code>IntervalMDP.labelmap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">labelmap(dfa::DFA)</code></pre><p>Return the label index mapping <span>$2^{AP} \to \mathbb{N}$</span> of the Deterministic Finite Automaton. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/DFA.jl#L138-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.initial_state-Tuple{DFA}"><a class="docstring-binding" href="#IntervalMDP.initial_state-Tuple{DFA}"><code>IntervalMDP.initial_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initial_state(dfa::DFA)</code></pre><p>Return the initial state of the Deterministic Finite Automaton. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/DFA.jl#L145-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.ProductProcess"><a class="docstring-binding" href="#IntervalMDP.ProductProcess"><code>IntervalMDP.ProductProcess</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ProductProcess{
    M &lt;: IntervalMarkovProcess,
    D &lt;: DeterministicAutomaton,
    L &lt;: AbstractLabelling,
}</code></pre><p>A type representing the product between interval Markov processes (e.g. <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a>) and an automaton (typically a deterministic finite automaton <a href="#IntervalMDP.DFA"><code>DFA</code></a>). </p><p>Formally, given an interval Markov process <span>$M = (S, A, \Gamma, S_{0})$</span>, a labelling function <span>$L : S \to 2^{AP}$</span>, and a DFA <span>$D = (Q, 2^{AP}, \delta, q_{0}, Q_{ac})$</span>, then a product process is a tuple <span>$M_{prod} = (Z, A, \Gamma^{prod}, Z_{ac}, Z_{0})$</span> where </p><ul><li><span>$Z = S \times Q$</span> is the set of product states q = (s, z)``,</li><li><span>$Q_{0} = S_0 \times \{q_0\} \subset Z$</span> is the set of initial product states <span>$z_0 = (s_0, q_0)$</span>,</li><li><span>$Z_{ac} = S \times Q_{ac} \subseteq Z$</span> is the set of accepting product states,</li><li><span>$A$</span> is the set of actions, and</li><li><span>$\Gamma^{prod} = \{\Gamma^{prod}_{z,a}\}_{z \in Z, a \in A}$</span> where <span>$\Gamma^{prod}_{z,a} = \{ \gamma_{z,a} : \gamma_{z,a}((t, z&#39;)) = \gamma_{s,a}(t)\delta_{q,L(s)}(z&#39;) \}$</span></li></ul><p>is a set of ambiguity sets on the product transition probabilities, for each product source-action pair.</p><p>See <a href="#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a> and <a href="#IntervalMDP.DFA"><code>DFA</code></a> for more information on the structure, definition, and usage of the DFA and IMDP.</p><p><strong>Fields</strong></p><ul><li><code>mdp::M</code>: contains details for the interval Markov process.</li><li><code>dfa::D</code>: contains details for the DFA</li><li><code>labelling_func::L</code>: the labelling function from IMDP states to DFA actions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/ProductProcess.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.markov_process-Tuple{ProductProcess}"><a class="docstring-binding" href="#IntervalMDP.markov_process-Tuple{ProductProcess}"><code>IntervalMDP.markov_process</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">markov_process(proc::ProductIntervalMarkovDecisionProcessDFA)</code></pre><p>Return the interval markov decision process of the product </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/ProductProcess.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.automaton-Tuple{ProductProcess}"><a class="docstring-binding" href="#IntervalMDP.automaton-Tuple{ProductProcess}"><code>IntervalMDP.automaton</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">automaton(proc::ProductIntervalMarkovDecisionProcessDFA)</code></pre><p>Return the deterministic finite automaton of the product </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/ProductProcess.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.labelling_function-Tuple{ProductProcess}"><a class="docstring-binding" href="#IntervalMDP.labelling_function-Tuple{ProductProcess}"><code>IntervalMDP.labelling_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">labelling_function(proc::ProductProcess)</code></pre><p>Return the labelling function of the product </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/models/ProductProcess.jl#L73-L77">source</a></section></details></article><h3 id="Transition-function-for-DFA"><a class="docs-heading-anchor" href="#Transition-function-for-DFA">Transition function for DFA</a><a id="Transition-function-for-DFA-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-function-for-DFA" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="IntervalMDP.TransitionFunction"><a class="docstring-binding" href="#IntervalMDP.TransitionFunction"><code>IntervalMDP.TransitionFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TransitionFunction{
    T &lt;: Integer, 
    MT &lt;: AbstractMatrix{T}
}</code></pre><p>A type representing the determininistic transition function of a DFA.</p><p>Formally, let <span>$T : |Q| \times |2^{AP}| =&gt; |Q|$</span> be a transition function, where </p><ul><li><span>$Q$</span> is the set of DFA states, and</li><li><span>$2^{AP}$</span> is the power set of atomic propositions</li></ul><p>Then the <code>TransitionFunction</code> type is defined as matrix which stores the mapping. The row indices are the alphabet indices and the column indices represent the states.  </p><p><strong>Fields</strong></p><ul><li><code>transition::MT</code>: transition functions encoded as matrix with labels on the rows, source states on the columns, and integer values for the destination.</li></ul><p>The choice to have labels on the rows is due to the column-major storage of matrices in Julia and the fact that we want the outer loop over DFA source states  in the Bellman operator <code>bellman!</code>.</p><p>We check that the transition matrix is valid, i.e. that all indices are positive and do not exceed the number of states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/TransitionFunction.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.transition-Tuple{TransitionFunction}"><a class="docstring-binding" href="#IntervalMDP.transition-Tuple{TransitionFunction}"><code>IntervalMDP.transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transition(transition_func::TransitionFunction)</code></pre><p>Return the transition matrix of the transition function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/TransitionFunction.jl#L52-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_states-Tuple{TransitionFunction}"><a class="docstring-binding" href="#IntervalMDP.num_states-Tuple{TransitionFunction}"><code>IntervalMDP.num_states</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_states(tf::TransitionFunction)</code></pre><p>Return the number of states <span>$|Q|$</span> of the transition function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/TransitionFunction.jl#L69-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_labels-Tuple{TransitionFunction}"><a class="docstring-binding" href="#IntervalMDP.num_labels-Tuple{TransitionFunction}"><code>IntervalMDP.num_labels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_labels(tf::TransitionFunction)</code></pre><p>Return the number of labels (DFA inputs) in the transition function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/TransitionFunction.jl#L75-L78">source</a></section></details></article><h3 id="Labelling-of-IMDP-states-to-Automaton-alphabet"><a class="docs-heading-anchor" href="#Labelling-of-IMDP-states-to-Automaton-alphabet">Labelling of IMDP states to Automaton alphabet</a><a id="Labelling-of-IMDP-states-to-Automaton-alphabet-1"></a><a class="docs-heading-anchor-permalink" href="#Labelling-of-IMDP-states-to-Automaton-alphabet" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="IntervalMDP.DeterministicLabelling"><a class="docstring-binding" href="#IntervalMDP.DeterministicLabelling"><code>IntervalMDP.DeterministicLabelling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DeterministicLabelling{
    T  &lt;: Integer, 
    AT &lt;: AbstractArray{T}
}</code></pre><p>A type representing the labelling of IMDP states into DFA inputs.</p><p>Formally, let <span>$L : S \to 2^{AP}$</span> be a labelling function, where </p><ul><li><span>$S$</span> is the set of IMDP states, and</li><li><span>$2^{AP}$</span> is the power set of atomic propositions</li></ul><p>Then the <code>DeterministicLabelling</code> type is defined as vector which stores the mapping. </p><p><strong>Fields</strong></p><ul><li><code>map::AT</code>: mapping function where indices are (factored) IMDP states and stored values are DFA inputs.</li><li><code>num_outputs::Int32</code>: number of labels accounted for in mapping.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/DeterministicLabelling.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.mapping-Tuple{DeterministicLabelling}"><a class="docstring-binding" href="#IntervalMDP.mapping-Tuple{DeterministicLabelling}"><code>IntervalMDP.mapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mapping(dl::DeterministicLabelling)</code></pre><p>Return the mapping array of the labelling function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/DeterministicLabelling.jl#L70-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_labels-Tuple{DeterministicLabelling}"><a class="docstring-binding" href="#IntervalMDP.num_labels-Tuple{DeterministicLabelling}"><code>IntervalMDP.num_labels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_labels(dl::DeterministicLabelling)</code></pre><p>Return the number of labels (DFA inputs) in the labelling function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/DeterministicLabelling.jl#L84-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.state_values-Tuple{DeterministicLabelling}"><a class="docstring-binding" href="#IntervalMDP.state_values-Tuple{DeterministicLabelling}"><code>IntervalMDP.state_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_values(dl::DeterministicLabelling)</code></pre><p>Return a tuple with the number of states for each state variable of the labeling function <span>$L : S \to 2^{AP}$</span>, which can be multiple dimensions in case of factored IMDPs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/DeterministicLabelling.jl#L90-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.ProbabilisticLabelling"><a class="docstring-binding" href="#IntervalMDP.ProbabilisticLabelling"><code>IntervalMDP.ProbabilisticLabelling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ProbabilisticLabelling{
    R &lt;: Real, 
    MR &lt;: AbstractMatrix{R}
}</code></pre><p>A type representing the Probabilistic labelling of IMDP states into DFA inputs. Each labelling is assigned a probability.</p><p>Formally, let <span>$L : S \times 2^{AP} \to [0, 1]$</span> be a labelling function, where </p><ul><li><span>$S$</span> is the set of IMDP states, and</li><li><span>$2^{AP}$</span> is the power set of atomic propositions</li></ul><p>Then the <code>ProbabilisticLabelling</code> type is defined as matrix which stores the mapping. </p><p><strong>Fields</strong></p><ul><li><code>map::MT</code>: mapping function encoded as matrix with labels on the rows, IMDP states on the columns, and valid probability values for the destination.</li></ul><p>The choice to have labels on the rows is due to the column-major storage of matrices in Julia and the fact that we want the inner loop over DFA target states  in the Bellman operator <code>bellman!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/ProbabilisticLabelling.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.mapping-Tuple{ProbabilisticLabelling}"><a class="docstring-binding" href="#IntervalMDP.mapping-Tuple{ProbabilisticLabelling}"><code>IntervalMDP.mapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mapping(pl::ProbabilisticLabelling)</code></pre><p>Return the mapping matrix of the probabilistic labelling function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/ProbabilisticLabelling.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.num_labels-Tuple{ProbabilisticLabelling}"><a class="docstring-binding" href="#IntervalMDP.num_labels-Tuple{ProbabilisticLabelling}"><code>IntervalMDP.num_labels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_labels(pl::ProbabilisticLabelling)</code></pre><p>Return the number of labels (DFA inputs) in the probabilistic labelling function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/ProbabilisticLabelling.jl#L69-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IntervalMDP.state_values-Tuple{ProbabilisticLabelling}"><a class="docstring-binding" href="#IntervalMDP.state_values-Tuple{ProbabilisticLabelling}"><code>IntervalMDP.state_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_values(pl::ProbabilisticLabelling)</code></pre><p>Return a tuple with the number of states for each state variable of the labeling function <span>$L : S \to 2^{AP}$</span>, which can be multiple dimensions in case of factored IMDPs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/5be37586ddc736ccfc8a44a89e74b0f9c144b463/src/probabilities/ProbabilisticLabelling.jl#L75-L78">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../algorithms/">« Algorithms</a><a class="docs-footer-nextpage" href="../specifications/">Specifications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 16:55">Thursday 4 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
