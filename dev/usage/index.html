<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · IntervalMDP.jl</title><meta name="title" content="Usage · IntervalMDP.jl"/><meta property="og:title" content="Usage · IntervalMDP.jl"/><meta property="twitter:title" content="Usage · IntervalMDP.jl"/><meta name="description" content="Documentation for IntervalMDP.jl."/><meta property="og:description" content="Documentation for IntervalMDP.jl."/><meta property="twitter:description" content="Documentation for IntervalMDP.jl."/><meta property="og:url" content="https://www.baymler.com/IntervalMDP.jl/usage/"/><meta property="twitter:url" content="https://www.baymler.com/IntervalMDP.jl/usage/"/><link rel="canonical" href="https://www.baymler.com/IntervalMDP.jl/usage/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="IntervalMDP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">IntervalMDP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Sparse-matrices"><span>Sparse matrices</span></a></li><li><a class="tocitem" href="#CUDA"><span>CUDA</span></a></li></ul></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../reference/systems/">Systems</a></li><li><a class="tocitem" href="../reference/specifications/">Specifications</a></li><li><a class="tocitem" href="../reference/solve/">Solve Interface</a></li><li><a class="tocitem" href="../reference/data/">Data Storage</a></li><li><a class="tocitem" href="../api/">Index</a></li></ul></li><li><a class="tocitem" href="../data/">Data formats</a></li><li><a class="tocitem" href="../developer/">Developer docs</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl/blob/main/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The general procedure for using this package can be described in 5 steps</p><ol><li>Construct a model, e.g. an Interval Markov Decision Process (IMDP) or some other subclass of <a href="../reference/systems/#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a>.</li><li>Choose property (reachability/reach-avoid/safety/reward + finite/infinite horizon).</li><li>Choose specification (optimistic/pessimistic + maximize/minimize + property).</li><li>Combine system and specification in a <code>VerificationProblem</code> or <code>ControlSynthesisProblem</code>, depending on whether you want to verify or synthesize a controller or not.</li><li>Call <a href="../reference/solve/#CommonSolve.solve"><code>solve</code></a> with the constructed problem and optionally a chosen algorithm. If no algorithm is given, a default algorithm will be chosen.</li></ol><p>First, we construct a system; for the purpose of this example, we will construct either an IMDP. For more information about the different models, see <a href="../models/#Models">Models</a>. Note that all subclasses of <a href="../reference/systems/#IntervalMDP.FactoredRobustMarkovDecisionProcess"><code>FactoredRobustMarkovDecisionProcess</code></a> are converted to an fRMDP internally for verification and control synthesis, and the default algorithm is inferred based on the structure of the fRMDP. An fRMDP consist of state variables (each can take on a finite number of values), action variables (similar to state variables), designated initial states, and a transition model; more specifically, the product of ambiguity sets for each marginal. See <a href="../models/#Factored-RMDPs">Factored RMDPs</a> for more information about transition model.</p><p>An example of how to construct IMDP is the following:</p><pre><code class="language-julia hljs">using IntervalMDP

# IMDP
prob1 = IntervalAmbiguitySets(;
    lower = [
        0.0 0.5
        0.1 0.3
        0.2 0.1
    ],
    upper = [
        0.5 0.7
        0.6 0.5
        0.7 0.3
    ],
)

prob2 = IntervalAmbiguitySets(;
    lower = [
        0.1 0.2
        0.2 0.3
        0.3 0.4
    ],
    upper = [
        0.6 0.6
        0.5 0.5
        0.4 0.4
    ],
)

prob3 = IntervalAmbiguitySets(;
    lower = [
        0.0 0.0
        0.0 0.0
        1.0 1.0
    ],
    upper = [
        0.0 0.0
        0.0 0.0
        1.0 1.0
    ],
)

transition_probs = [prob1, prob2, prob3]
initial_states = [1]  # Initial states are optional
mdp = IntervalMarkovDecisionProcess(transition_probs, initial_states)

# output

FactoredRobustMarkovDecisionProcess
├─ 1 state variables with cardinality: (3,)
├─ 1 action variables with cardinality: (2,)
├─ Initial states: [1]
├─ Transition marginals:
│  └─ Marginal 1:
│     ├─ Conditional variables: states = (1,), actions = (1,)
│     └─ Ambiguity set type: Interval (dense, Matrix{Float64})
└─Inferred properties
   ├─Model type: Interval MDP
   ├─Number of states: 3
   ├─Number of actions: 2
   ├─Default model checking algorithm: Robust Value Iteration
   └─Default Bellman operator algorithm: O-Maximization</code></pre><p>Note that for an IMDP, the transition probabilities are specified as a list of transition probabilities (with each column representing an action) for each state. The constructor will concatenate the transition probabilities into a single matrix, such that the columns represent source/action pairs and the rows represent target states.</p><div class="admonition is-success" id="Tip-43713dd41dd6c1b8"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-43713dd41dd6c1b8" title="Permalink"></a></header><div class="admonition-body"><p>IMDPs can be very memory intensive if the ambiguity sets are stored as dense matrices. To reduce memory usage, consider using <a href="#Sparse-matrices">Sparse matrices</a> and/or <a href="../models/#Factored-RMDPs">Factored RMDPs</a> (recommended).</p></div></div><p>Next, we choose a property. Currently supported are reachability, reach-avoid, safety, reward, expected exit time and DFA-based properties. For this example, we will use a reachability property, which requires specifying a set of target states <code>target_set</code>. Furthermore, this package distinguishes distinguish between finite and infinite horizon properties - for finite horizon, a time horizon must be given, while for infinite horizon, a convergence threshold must be provided. </p><p>In addition to the property, we need to specify whether we want to maximize or minimize the optimistic or pessimistic value (the value being satisfaction probability, discounted reward, etc.). We call this a specification.</p><pre><code class="language-julia hljs"># Reachability
target_set = [3]
prop = FiniteTimeReachability(target_set, 10)  # Time steps
prop = InfiniteTimeReachability(target_set, 1e-6)  # Residual tolerance

## Specification
spec = Specification(prop, Pessimistic, Maximize)
spec = Specification(prop, Pessimistic, Minimize)
spec = Specification(prop, Optimistic, Maximize)
spec = Specification(prop, Optimistic, Minimize)

## Combine system and specification in a Problem
verification_problem = VerificationProblem(mdp, spec) # use `VerificationProblem(mdp, spec, strategy)` to verify under a given strategy
control_problem = ControlSynthesisProblem(mdp, spec)

# output

ControlSynthesisProblem
├─ FactoredRobustMarkovDecisionProcess
│  ├─ 1 state variables with cardinality: (3,)
│  ├─ 1 action variables with cardinality: (2,)
│  ├─ Initial states: [1]
│  ├─ Transition marginals:
│  │  └─ Marginal 1:
│  │     ├─ Conditional variables: states = (1,), actions = (1,)
│  │     └─ Ambiguity set type: Interval (dense, Matrix{Float64})
│  └─Inferred properties
│     ├─Model type: Interval MDP
│     ├─Number of states: 3
│     ├─Number of actions: 2
│     ├─Default model checking algorithm: Robust Value Iteration
│     └─Default Bellman operator algorithm: O-Maximization
└─ Specification
   ├─ Satisfaction mode: Optimistic
   ├─ Strategy mode: Minimize
   └─ Property: InfiniteTimeReachability
      ├─ Convergence threshold: 1.0e-6
      └─ Reach states: CartesianIndex{1}[CartesianIndex(3,)]</code></pre><div class="admonition is-success" id="Tip-239b81a06c2c22d3"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-239b81a06c2c22d3" title="Permalink"></a></header><div class="admonition-body"><p>For complex properties, e.g. LTLf, it is necessary to construct a Definite Finite Automaton (DFA) and (lazily) build the product with the fRMDP. See <a href="../specifications/#Complex-properties">Complex properties</a> for more details on the product construction and DFA properties. Note that constructing the DFA from an LTLf formula is currently not supported by this package. </p></div></div><p>Finally, we call <a href="../reference/solve/#CommonSolve.solve"><code>solve</code></a> to solve the specification. <code>solve</code> returns the value function for all states in addition to the number of iterations performed and the last Bellman residual, wrapped in a solution object.</p><pre><code class="language-julia hljs">sol = solve(verification_problem) # or solve(problem, alg) where e.g. alg = RobustValueIteration(LPMcCormickRelaxation()) to specify the algorithm
V, k, res = sol

# or alternatively
V, k, res = value_function(sol), num_iterations(sol), residual(sol)

# For control synthesis, we also get a strategy
sol = solve(control_problem)
V, k, res, strategy = sol</code></pre><p>For now, only <a href="../reference/solve/#IntervalMDP.RobustValueIteration"><code>RobustValueIteration</code></a> is supported, but more algorithms are planned.</p><div class="admonition is-info" id="Note-5af55d4c2744cc0e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5af55d4c2744cc0e" title="Permalink"></a></header><div class="admonition-body"><p>To use multi-threading for parallelization, you need to either start julia with <code>julia --threads &lt;n|auto&gt;</code> where <code>n</code> is a positive integer or to set the environment variable <code>JULIA_NUM_THREADS</code> to the number of threads you want to use. For more information, see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">Multi-threading</a>.</p></div></div><h2 id="Sparse-matrices"><a class="docs-heading-anchor" href="#Sparse-matrices">Sparse matrices</a><a id="Sparse-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-matrices" title="Permalink"></a></h2><p>A disadvantage of IMDPs is that the size of the transition matrices grows <span>$O(n^2 m)$</span> where <span>$n$</span> is the number of states and <span>$m$</span> is the number of actions. Quickly, this becomes infeasible to store in memory. However, IMDPs frequently have lots of sparsity we may exploit. We choose in particular to store the transition matrices in the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)">Compressed Sparse Column (CSC)</a> format. This is a format that is widely used in Julia and other languages, and is supported by many linear algebra operations. The format consists of three arrays: <code>colptr</code>, <code>rowval</code> and <code>nzval</code>. The <code>colptr</code> array stores the indices of the first non-zero value in each column. The <code>rowval</code> array stores the row indices of the non-zero values, and the <code>nzval</code> array stores the non-zero values. We choose this format, since source states are stored as columns (see <a href="../reference/systems/#IntervalMDP.IntervalAmbiguitySets"><code>IntervalAmbiguitySets</code></a> and <a href="../reference/systems/#IntervalMDP.Marginal"><code>Marginal</code></a> for more information about the structure of the transition probability matrices). Thus the non-zero values for each source state is stored in sequentially in memory, enabling efficient memory access.</p><p>To use <code>SparseMatrixCSC</code>, we need to load <code>SparseArrays</code>. Below is an example of how to construct an <code>IntervalMarkovChain</code> with sparse transition matrices.</p><pre><code class="language-julia hljs">using SparseArrays

lower = spzeros(3, 3)
lower[2, 1] = 0.1
lower[3, 1] = 0.2
lower[1, 2] = 0.5
lower[2, 2] = 0.3
lower[3, 2] = 0.1
lower[3, 3] = 1.0

lower</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 6 stored entries:
  ⋅   0.5   ⋅ 
 0.1  0.3   ⋅ 
 0.2  0.1  1.0</code></pre><pre><code class="language-julia hljs">upper = spzeros(3, 3)
upper[1, 1] = 0.5
upper[2, 1] = 0.6
upper[3, 1] = 0.7
upper[1, 2] = 0.7
upper[2, 2] = 0.5
upper[3, 2] = 0.3
upper[3, 3] = 1.0

upper</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
 0.5  0.7   ⋅ 
 0.6  0.5   ⋅ 
 0.7  0.3  1.0</code></pre><pre><code class="language-julia hljs">prob = IntervalAmbiguitySets(; lower = lower, upper = upper)
initial_state = 1
imc = IntervalMarkovChain(prob, initial_state)</code></pre><p>If you know that the matrix can be built sequentially, you can use the <code>SparseMatrixCSC</code> constructor directly with <code>colptr</code>, <code>rowval</code> and <code>nzval</code>. This is more efficient, since <code>setindex!</code> of <code>SparseMatrixCSC</code> needs to perform a binary search to find the correct index to insert the value, and possibly expand the size of the array.</p><h2 id="CUDA"><a class="docs-heading-anchor" href="#CUDA">CUDA</a><a id="CUDA-1"></a><a class="docs-heading-anchor-permalink" href="#CUDA" title="Permalink"></a></h2><p>This package is supports GPU-accelerated value iteration via CUDA (only for <a href="../models/#IMDPs"><code>IMDPs</code></a> and <a href="../models/#IMCs"><code>IMCs</code></a> at the moment). This includes not only trivial parallelization across states but also parallel algorithms for O-maximization within each state for better computational efficiency and coalesced memory access for more speed.</p><p>To use CUDA, you need to first install <code>CUDA.jl</code>. For more information about this, see <a href="../#Installation">Installation</a>. Next, you need to load the package with the following command:</p><pre><code class="language-julia hljs">using CUDA</code></pre><p>Loading CUDA will automatically load an extension that defines Bellman operators when the ambiguity sets are specified as CUDA arrays. It has been separated out into an extension to reduce precompilation time for users that do not need CUDA. Note that loading CUDA on a system without a CUDA-capable GPU, will not cause any errors, but only when running. You can check if CUDA is available using <code>CUDA.functional()</code>.</p><p>To use CUDA, you need to transfer the model to the GPU. Once on the GPU, you can use the same functions as the CPU implementation. Using Julia&#39;s multiple dispatch, the package will automatically dispatch to the appropriate implementation of the Bellman operators.</p><p>Similar to <code>CUDA.jl</code>, we provide a <code>cu</code> function that transfers the model to the GPU<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup>. You can either transfer the entire model or transfer the transition matrices separately. </p><pre><code class="language-julia hljs"># Transfer entire model to GPU
prob = IntervalAmbiguitySets(;
    lower = sparse_hcat(
        SparseVector(3, [2, 3], [0.1, 0.2]),
        SparseVector(3, [1, 2, 3], [0.5, 0.3, 0.1]),
        SparseVector(3, [3], [1.0]),
    ),
    upper = sparse_hcat(
        SparseVector(3, [1, 2, 3], [0.5, 0.6, 0.7]),
        SparseVector(3, [1, 2, 3], [0.7, 0.5, 0.3]),
        SparseVector(3, [3], [1.0]),
    ),
)

mc = IntervalMDP.cu(IntervalMarkovChain(prob, 1))

# Transfer ambiguity sets to GPU
prob = IntervalMDP.cu(IntervalAmbiguitySets(;
    lower = sparse_hcat(
        SparseVector(3, [2, 3], [0.1, 0.2]),
        SparseVector(3, [1, 2, 3], [0.5, 0.3, 0.1]),
        SparseVector(3, [3], [1.0]),
    ),
    upper = sparse_hcat(
        SparseVector(3, [1, 2, 3], [0.5, 0.6, 0.7]),
        SparseVector(3, [1, 2, 3], [0.7, 0.5, 0.3]),
        SparseVector(3, [3], [1.0]),
    ),
))

mc = IntervalMarkovChain(prob, [1])

# Transfer transition matrices separately
prob = IntervalAmbiguitySets(;
    lower = IntervalMDP.cu(sparse_hcat(
        SparseVector(3, [2, 3], [0.1, 0.2]),
        SparseVector(3, [1, 2, 3], [0.5, 0.3, 0.1]),
        SparseVector(3, [3], [1.0]),
    )),
    upper = IntervalMDP.cu(sparse_hcat(
        SparseVector(3, [1, 2, 3], [0.5, 0.6, 0.7]),
        SparseVector(3, [1, 2, 3], [0.7, 0.5, 0.3]),
        SparseVector(3, [3], [1.0]),
    )),
)

mc = IntervalMarkovChain(prob, [1])</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>The difference to <code>CUDA.jl</code>&#39;s <code>cu</code> function is that <code>IntervalMDPs.jl</code>&#39;s <code>cu</code> is opinionated to preserve value types and use <code>Int32</code> indices, to reduce register pressure but maintain accuracy</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../models/">Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 12:44">Thursday 4 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
