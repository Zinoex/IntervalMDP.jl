<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · IntervalMDP.jl</title><meta name="title" content="Algorithms · IntervalMDP.jl"/><meta property="og:title" content="Algorithms · IntervalMDP.jl"/><meta property="twitter:title" content="Algorithms · IntervalMDP.jl"/><meta name="description" content="Documentation for IntervalMDP.jl."/><meta property="og:description" content="Documentation for IntervalMDP.jl."/><meta property="twitter:description" content="Documentation for IntervalMDP.jl."/><meta property="og:url" content="https://www.baymler.com/IntervalMDP.jl/algorithms/"/><meta property="twitter:url" content="https://www.baymler.com/IntervalMDP.jl/algorithms/"/><link rel="canonical" href="https://www.baymler.com/IntervalMDP.jl/algorithms/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="IntervalMDP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">IntervalMDP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Model-checking"><span>Model checking</span></a></li><li><a class="tocitem" href="#Bellman-operator-algorithms"><span>Bellman operator algorithms</span></a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../reference/systems/">Systems</a></li><li><a class="tocitem" href="../reference/specifications/">Specifications</a></li><li><a class="tocitem" href="../reference/solve/">Solve Interface</a></li><li><a class="tocitem" href="../reference/data/">Data Storage</a></li><li><a class="tocitem" href="../api/">Index</a></li></ul></li><li><a class="tocitem" href="../data/">Data formats</a></li><li><a class="tocitem" href="../developer/">Developer docs</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl/blob/main/docs/src/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><h2 id="Model-checking"><a class="docs-heading-anchor" href="#Model-checking">Model checking</a><a id="Model-checking-1"></a><a class="docs-heading-anchor-permalink" href="#Model-checking" title="Permalink"></a></h2><p>The core algorithmic component of this package is (robust) value iteration, which is used to solve verification and control synthesis problems for fRMDPs. Value iteration is an iterative algorithm that computes the value function for a given specification by repeatedly applying the <a href="#Bellman-operator-algorithms">Bellman operator</a> until convergence.</p><p>To simplify the dicussion on the algorithmic choices, we will assume that the goal is to compute the maximizing pessimistic probability of reaching a set of states <span>$G$</span>, that is, </p><p class="math-container">\[\max_{\pi} \; \min_{\eta} \;  \mathbb{P}^{\pi, \eta}_{\mathrm{reach}}(G, K).\]</p><p>See <a href="../models/#Models">Models</a> for more details on the formal definition of fRMDPs, strategies, and adversaries; in this case the maximization and minimization operators respectively. The algorithms are easily adapted to <a href="../specifications/#Specifications">other specifications</a>.</p><p>Computing the solution to the above problem can be framed in terms of value iteration. The value function <span>$V_k$</span> is the probability of reaching <span>$G$</span> in <span>$k$</span> steps or fewer. The value function is initialized to <span>$V_0(s) = 1$</span> if <span>$s \in G$</span> and <span>$V_0(s) = 0$</span> otherwise. The value function is then iteratively updated according to the Bellman equation</p><p class="math-container">\[\begin{aligned}
    V_{0}(s) &amp;= \mathbf{1}_{G}(s) \\
    V_{k}(s) &amp;= \mathbf{1}_{G}(s) + \mathbf{1}_{S \setminus G}(s) \max_{a \in A} \min_{\gamma_{s,a} \in \Gamma_{s,a}} \sum_{t \in S} V_{k-1}(t) \gamma_{s,a}(t),
\end{aligned}\]</p><p>where <span>$\mathbf{1}_{G}(s) = 1$</span>  if <span>$s \in G$</span> and <span>$0$</span> otherwise is the indicator function for set <span>$G$</span>. This Bellman update is repeated until <span>$k = K$</span>, or if <span>$K = \infty$</span>, until the value function converges, i.e. <span>$V_k = V_{k-1}$</span> for some <span>$k$</span>. The value function is then the solution to the problem.</p><p>In a more programmatic formulation, the algorithm can be summarized as follows:</p><pre><code class="language-julia hljs">function value_iteration(system, spec)
    V = initialize_value_function(spec)  # E.g. V[s] = 1 if s in G else 0 for reachability

    while !converged(V)  # or for k in 1:K if K is finite
        # Compute max_{a \in A} \min_{γ_{s,a} \in Γ_{s,a}} \sum_{t \in S} V_{k-1}(t) γ_{s,a}(t) for all states s
        V = bellman_update(V, system) # System contains information about S, A, and Γ
        post_process!(V, spec) # E.g. set V[s] = 1 for s in G for reachability
    end
end</code></pre><p>We slightly abuse terminology and call the max/min expectation the Bellman update, even though it is not a proper Bellman operator as it does not include the indicator function for <span>$G$</span>. The min/max expectation is however shared between all specifications, and thus it is natural to separate it from the specification-dependent post-processing step.</p><p>Note that exact convergence is virtually, impossible, unless using (computationally slow) exact arithmetic, to achieve in a finite number of iterations due to the finite precision of floating point numbers. Hence, we instead use a residual tolerance <span>$\epsilon$</span> and stop when Bellman residual <span>$V_k - V_{k-1}$</span> is less than the threshold, <span>$\|V_k - V_{k-1}\|_\infty &lt; \epsilon$</span>. See <a href="#Bellman-operator-algorithms">Bellman operator algorithms</a> for algorithms that support exact arithmetic.</p><h2 id="Bellman-operator-algorithms"><a class="docs-heading-anchor" href="#Bellman-operator-algorithms">Bellman operator algorithms</a><a id="Bellman-operator-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Bellman-operator-algorithms" title="Permalink"></a></h2><p>As the Bellman update is the most computationally intensive part of the algorithm, it is crucial to implement it efficiently including considerations about type stability, pre-allocation and in-place operations, memory access patterns, and parallelization.</p><ol><li>Type stability: the Bellman update should be type stable, i.e. the correct kernel to dispatch to should be inferable at compile time, to avoid dynamic dispatch and heap allocations in the hot loop. This can be achieved by using parametric types and avoiding abstract types in the hot loop.</li><li>Pre-allocation and in-place operations: to avoid unnecessary allocations and reducing GC pressure, the value function (pre and post Bellman update) is be pre-allocated and updated in-place, and the Bellman update relies on pre-allocated workspace objects.</li><li>Memory access patterns: to ensure cache efficiency, the memory access pattern should be as contiguous as possible. This is achieved by storing the transition matrices/ambiguity sets in column-major order, where each column corresponds to a source-action pair.</li><li>Parallelization: to leverage multi-core CPUs and CUDA hardware, the Bellman update should be parallelized across source-states and in the case of CUDA, also across actions and target states.</li></ol><p>A challenge with designing Bellman operator algorithms for fRMDPs is that <span>$\min_{\gamma_{s,a} \in \Gamma_{s,a}} \sum_{t \in S} V_{k-1}(t) \gamma_{s,a}(t)$</span> is not always computable exactly, and thus, we must resort to sound approximations. For IMDPs, the minimum can be computed exactly via <a href="#O-maximization">O-maximization</a>. Below, we will describe different algorithms for computing the Bellman update, their trade-offs, and algorithmic choices for an efficient implementation.</p><h3 id="O-maximization"><a class="docs-heading-anchor" href="#O-maximization">O-maximization</a><a id="O-maximization-1"></a><a class="docs-heading-anchor-permalink" href="#O-maximization" title="Permalink"></a></h3><p>In case of an IMDP, the minimum over all feasible distributions can be computed as a solution to a Linear Programming (LP) problem, namely</p><p class="math-container">\[    \begin{aligned}
        \min_{\gamma_{s, a}} \quad &amp; \sum_{t \in S} V_{k-1}(t) \cdot \gamma_{s, a}(t), \\
        \quad &amp; \underline{\gamma}_{s, a}(t) \leq \gamma_{s, a}(t) \leq \overline{\gamma}_{s, a}(t) \quad \forall t \in S, \\
        \quad &amp; \sum_{t \in S} \gamma_{s,a}(t) = 1.
    \end{aligned}\]</p><p>However, due to the particular structure of the LP problem, we can use a more efficient algorithm: O-maximization, or ordering-maximization [<a href="../references/#givan2000bounded">7</a>, <a href="../references/#lahijanian2015formal">8</a>]. In the case of pessimistic probability, we want to assign the most possible probability mass to the destinations with the smallest value of <span>$V_{k-1}$</span>, while obeying that the probability distribution is feasible, i.e. within the probability bounds and that it sums to 1. This is done by sorting the values of <span>$V_{k-1}$</span> and then assigning state with the smallest value its upper bound, then the second smallest, and so on until the remaining mass must be assigned to the lower bound of the remaining states for probability distribution is feasible.</p><pre><code class="language-julia hljs">function min_value(V, system, source, action)
    # Sort values of `V` in ascending order
    order = sortperm(V)

    # Initialize distribution to lower bounds
    p = lower_bounds(system, source, action)
    budget = 1 - sum(p)

    # Assign upper bounds to states with smallest values
    # until remaining mass is zero
    for idx in order
        gap = upper_bounds(system, source, action)[idx] - p[idx]
        if budget &lt;= gap
            p[idx] += budget
            break
        else
            p[idx] += gap
            budget -= gap
        end
    end

    v = dot(V, p)
    return v
end</code></pre><p>For fIMDPs, O-maximization can be applied recursively over the marginals as a sound under-approximation of the minimum [<a href="../references/#mathiesen2025scalable">9</a>]. Let <span>$S = S_1 \times \cdots \times S_n$</span> be the state space factored into <span>$n$</span> state variables, and let <span>$\Gamma_{s,a} = \Gamma^1_{s,a} \times \cdots \times \Gamma^n_{s,a}$</span> be the transition ambiguity sets factored into <span>$n$</span> marginals. Then, we can compute a bound on the minimum as</p><p class="math-container">\[    \begin{aligned}
        W_{s,a}^{k,n}(t^1, \ldots, t^n) &amp;= V_{k - 1}(t)\\
        W_{s,a}^{k,i-1}(t^1, \ldots, t^{i-1}) &amp;= \min_{\gamma^i_{s,a} \in \Gamma^i_{s,a}} \sum_{t^i \in S_i} W_{s,a}^{k,i}(
            t^1, \ldots, t^i) \gamma^i_{s,a}(t^i),\\
            &amp;\qquad \qquad \text{ for } i = 2, \ldots, n \\
        W_{s,a}^{k} :=  W_{s,a}^{k,0} &amp;= \min_{\gamma^1_{s,a} \in \Gamma^1_{s,a}} \sum_{t^1 \in S_1} W_{s,a}^{k,1}(t^1) \gamma^1_{s,a}(t^1).
    \end{aligned}\]</p><p>Then, <span>$V_k(s) := \mathbf{1}_{G}(s) + \mathbf{1}_{S \setminus G}(s) \max_{a \in A} W_{s,a}^{k}$</span>. Note that this is strictly better than building a joint ambiguity set by multiplying the marginal interval bounds [<a href="../references/#mathiesen2025scalable">9</a>].</p><p>The algorithm is the default Bellman algorithm for IMDPs, but not for fIMDPs. To explicitly select (recursive) O-maximization, do the following:</p><pre><code class="language-julia hljs">alg = RobustValueIteration(OMaximization())
result = solve(problem, alg)</code></pre><p>O-maximization supports both floating point and exact arithmetic, and it is implemented for both CPU and CUDA hardware.</p><h3 id="Vertex-enumeration"><a class="docs-heading-anchor" href="#Vertex-enumeration">Vertex enumeration</a><a id="Vertex-enumeration-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-enumeration" title="Permalink"></a></h3><p>A way to compute the minimum exactly for fIMDPs, and in general polytopic ambiguity sets, is via vertex enumeration [<a href="../references/#schnitzer2025efficient">1</a>]. The idea is to enumerate the Cartesian product of all vertices of each polytope and then compute the minimum over the vertices. This is however only feasible for few state values along each marginal, as the potential number of vertices for each marginal can grow with the factorial of the number of state values, and exponentially in the number of dimensions. Hence, this algorithm is only feasible for small problems, but it is included for completeness and as a reference implementation. To use vertex enumeration, do the following:</p><pre><code class="language-julia hljs">alg = RobustValueIteration(VertexEnumeration())
result = solve(problem, alg)</code></pre><p>The implementation iterates vertex combinations in a lazy manner, and thus, it does not store all vertices in memory. Furthermore, efficient generation of vertices for each marginal is done via backtracking to avoid enumerating all possible orderings.</p><p>Vertex enumeration supports both floating point and exact arithmetic.</p><h3 id="Recursive-McCormick-envelopes"><a class="docs-heading-anchor" href="#Recursive-McCormick-envelopes">Recursive McCormick envelopes</a><a id="Recursive-McCormick-envelopes-1"></a><a class="docs-heading-anchor-permalink" href="#Recursive-McCormick-envelopes" title="Permalink"></a></h3><p>Another method for computing a sound under-approximation of the minimum for fIMDPs is via recursive McCormick envelopes [<a href="../references/#schnitzer2025efficient">1</a>]. The idea is to relace each bilinear term <span>$\gamma^1_{s, a}(t^1) \cdot \gamma^2_{s, a}(t^2)$</span> in <span>$\sum_{t \in S} V_{k-1}(&#39;) \gamma^1_{s, a}(t^1) \cdot \gamma^2_{s, a}(t^2)$</span> (for a system with two marginals) with a new variable <span>$q_{s, a}(t^1, t^2)$</span> and add linear McCormick constraints to ensure that <span>$q_{s, a}(t^1, t^2)$</span> is an over-approximation of the bilinear term. That is,</p><p class="math-container">\[    \begin{aligned}
        q_{s, a}(t^1, t^2) &amp;\geq \underline{\gamma}^1_{s,a}(t^1) \cdot \gamma^2_{s,a}(t^2) + \underline{\gamma}^2_{s,a}(t^2) \cdot \gamma^1_{s,a}(t^1) - \underline{\gamma}^1_{s,a}(t^1) \cdot \underline{\gamma}^2_{s,a}(t^2), \\
        q_{s, a}(t^1, t^2) &amp;\geq \overline{\gamma}^1_{s,a}(t^1) \cdot \gamma^2_{s,a}(t^2) + \overline{\gamma}^2_{s,a}(t^2) \cdot \gamma^1_{s,a}(t^1) - \overline{\gamma}^1_{s,a}(t^1) \cdot \overline{\gamma}^2_{s,a}(t^2), \\
        q_{s, a}(t^1, t^2) &amp;\leq \underline{\gamma}^1_{s,a}(t^1) \cdot \gamma^2_{s,a}(t^2) + \overline{\gamma}^2_{s,a}(t^2) \cdot \gamma^1_{s,a}(t^1) - \underline{\gamma}^1_{s,a}(t^1) \cdot \overline{\gamma}^2_{s,a}(t^2), \\
        q_{s, a}(t^1, t^2) &amp;\leq \overline{\gamma}^1_{s,a}(t^1) \cdot \gamma^2_{s,a}(t^2) + \underline{\gamma}^2_{s,a}(t^2) \cdot \gamma^1_{s,a}(t^1) - \overline{\gamma}^1_{s,a}(t^1) \cdot \underline{\gamma}^2_{s,a}(t^2).
    \end{aligned}\]</p><p>In addition, we add the constraint that <span>$\sum_{t^1 \in S_1} \sum_{t^2 \in S_2} q_{s, a}(t^1, t^2) = 1$</span> such that <span>$q_{s, a}$</span> is a valid probability distribution.</p><p>This results in a Linear Programming (LP) problem that can be solved efficiently. The McCormick envelopes can be applied recursively for more than two marginals. The algorithm is more efficient than vertex enumeration and is thus the default Bellman algorithm for fIMDPs.</p><p>To use recursive McCormick envelopes, do the following:</p><pre><code class="language-julia hljs"># Use default LP solver (HiGHS)
alg = RobustValueIteration(LPMcCormickRelaxation())

# Choose a different LP solver
using Clarabel
alg = RobustValueIteration(LPMcCormickRelaxation(; lp_solver=Clarabel.Optimizer))

result = solve(problem, alg)</code></pre><p>See the <a href="https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers">JuMP documentation</a> for a list of supported LP solvers. The recursive McCormick envelopes Bellman operator algorithm supports primarily floating point, but also exact arithmetic if the chosen LP solver does.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../specifications/">« Specifications</a><a class="docs-footer-nextpage" href="../reference/systems/">Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 14:20">Thursday 4 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
